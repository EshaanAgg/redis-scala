package redis

import redis.formats.RESPData
import redis.formats.RESPData.BulkString

import java.time.Instant
import scala.collection.mutable.TreeMap

case class EntryID(msTime: Long, seq: Long):
  override def toString: String = s"$msTime-$seq"

  def getRESP: RESPData =
    BulkString(this.toString)

  def isBiggerThan(other: EntryID): Boolean =
    if this.msTime > other.msTime then true
    else if this.msTime == other.msTime then this.seq > other.seq
    else false

object EntryID:
  private def getAutogeneraredID(streamName: String): EntryID =
    val lastEntry = StreamStore.lastEntry(streamName)
    val curTimeMs = Instant.now().toEpochMilli()
    lastEntry match
      case None => EntryID(curTimeMs, 0)
      case Some(last) =>
        if last.msTime < curTimeMs then EntryID(curTimeMs, 0)
        else EntryID(last.msTime, last.seq + 1)

  private def getPartiallyAutogeneratedID(
      streamName: String,
      seqTime: Long
  ): EntryID =
    val lastEntry = StreamStore.lastEntry(streamName, seqTime)
    val defaultSeq = if seqTime == 0 then 1 else 0
    lastEntry match
      case None        => EntryID(seqTime, defaultSeq)
      case Some(value) => EntryID(value.msTime, value.seq + 1)

  private def validateID(streamName: String, id: EntryID): Option[String] =
    val lastEntry = StreamStore.lastEntry(streamName)
    if !id.isBiggerThan(EntryID(0, 0))
    then Some("ERR The ID specified in XADD must be greater than 0-0")
    else if lastEntry.isDefined && !id.isBiggerThan(lastEntry.get)
    then
      Some(
        "ERR The ID specified in XADD is equal or smaller than the target stream top item"
      )
    else None

  def apply(streamName: String, id: String): Either[String, EntryID] =
    if id == "*" then Right(getAutogeneraredID(streamName))
    else
      val parts = id.split("-")
      if parts.length != 2
      then Left(s"Invalid ID format: $id")
      else if parts(1) == "*" then
        val seqTime = parts(0).toLong
        Right(getPartiallyAutogeneratedID(streamName, seqTime))
      else
        val msTime = parts(0).toLong
        val seq = parts(1).toLong
        val entryID = EntryID(msTime, seq)
        validateID(streamName, entryID) match
          case Some(err) => Left(err)
          case None      => Right(entryID)

case class Entry(id: EntryID, data: Map[String, String])

object Entry:
  def apply(args: Array[String]): Either[String, Entry] =
    val streamName = args(0)
    args.drop(1).grouped(2).map(p => p(0) -> p(1)).toMap match
      case data if data.isEmpty =>
        Left("ERR XADD requires at least one field-value pair")
      case data =>
        EntryID(streamName, args(0)) match
          case Right(id) => Right(Entry(id, data))
          case Left(err) => Left(err)

type StreamData = List[Entry]

object StreamStore:
  val streams: TreeMap[String, StreamData] = TreeMap[String, StreamData]()

  /** Creates a new stream with the given name if it does not already exist.
    * Throws an exception if the stream already exists.
    * @param name
    *   The name of the stream to create.
    */
  def makeStream(name: String): Unit =
    if !streams.contains(name) then streams(name) = List.empty
    else throw Exception(s"Stream '$name' already exists")

  /** Adds an entry to the specified stream. Creates the stream if it does not
    * exist.
    *
    * @param name
    *   The name of the stream to which the entry will be added.
    * @param entry
    *   The entry to add to the stream.
    */
  def addEntryToStream(name: String, entry: Entry): Unit =
    if streams.contains(name) then
      val stream = streams(name)
      streams(name) = stream :+ entry
      Some(entry)
    else
      makeStream(name)
      addEntryToStream(name, entry)

  def streamExists(name: String): Boolean =
    streams.contains(name)

  def lastEntry(name: String): Option[EntryID] =
    streams.get(name) match
      case Some(entries) if entries.nonEmpty =>
        Some(entries.last.id)
      case _ => None

  def lastEntry(name: String, timeMS: Long): Option[EntryID] =
    lastEntry(name) match
      case Some(entry) if entry.msTime == timeMS => Some(entry)
      case _                                     => None
