package redis

import redis.formats.RESPData
import redis.formats.RESPData.BulkString

import java.time.Instant
import scala.collection.mutable.TreeMap

case class EntryID(msTime: Long, seq: Long):
  override def toString: String = s"$msTime-$seq"

  def getRESP: RESPData =
    BulkString(this.toString)

  def >(other: EntryID): Boolean =
    if this.msTime > other.msTime then true
    else if this.msTime == other.msTime then this.seq > other.seq
    else false

  def <(other: EntryID): Boolean =
    if this.msTime < other.msTime then true
    else if this.msTime == other.msTime then this.seq < other.seq
    else false

  def <=(other: EntryID): Boolean =
    this < other || this == other

  def >=(other: EntryID): Boolean =
    this > other || this == other

object EntryID:
  private def getAutogeneraredID(streamName: String): EntryID =
    val lastEntry = StreamStore.lastEntry(streamName)
    val curTimeMs = Instant.now().toEpochMilli()
    lastEntry match
      case None => EntryID(curTimeMs, 0)
      case Some(last) =>
        if last.msTime < curTimeMs then EntryID(curTimeMs, 0)
        else EntryID(last.msTime, last.seq + 1)

  private def getPartiallyAutogeneratedID(
      streamName: String,
      seqTime: Long
  ): EntryID =
    val lastEntry = StreamStore.lastEntry(streamName, seqTime)
    val defaultSeq = if seqTime == 0 then 1 else 0
    lastEntry match
      case None        => EntryID(seqTime, defaultSeq)
      case Some(value) => EntryID(value.msTime, value.seq + 1)

  private def validateID(streamName: String, id: EntryID): Option[String] =
    val lastEntry = StreamStore.lastEntry(streamName)
    if id <= EntryID(0, 0)
    then Some("ERR The ID specified in XADD must be greater than 0-0")
    else if lastEntry.isDefined && id <= lastEntry.get
    then
      Some(
        "ERR The ID specified in XADD is equal or smaller than the target stream top item"
      )
    else None

  def apply(streamName: String, id: String): Either[String, EntryID] =
    if id == "*" then Right(getAutogeneraredID(streamName))
    else
      val parts = id.split("-")
      if parts.length != 2
      then Left(s"Invalid ID format: $id")
      else if parts(1) == "*" then
        val seqTime = parts(0).toLong
        Right(getPartiallyAutogeneratedID(streamName, seqTime))
      else
        val msTime = parts(0).toLong
        val seq = parts(1).toLong
        val entryID = EntryID(msTime, seq)
        validateID(streamName, entryID) match
          case Some(err) => Left(err)
          case None      => Right(entryID)

  def forRange(id: String): EntryID =
    val parts = id.split("-")
    if parts.length != 2
    then EntryID(id.toLong, 0) // Default ID for range queries
    else EntryID(parts(0).toLong, parts(1).toLong)

case class Entry(id: EntryID, data: Map[String, String]):
  def getResp: RESPData =
    RESPData.Array(
      id.getRESP,
      RESPData.Array(
        data
          .flatMap((k, v) => List(k, v))
          .map(RESPData.BulkString(_))
          .toList
      )
    )

object Entry:
  def apply(args: Array[String]): Either[String, Entry] =
    println(s"Creating entry from args: ${args.mkString(", ")}")
    EntryID(args(0), args(1)).map(id => {
      val data = args
        .drop(2)
        .grouped(2)
        .map(p => (p(0), p(1)))
        .toMap
      Entry(id, data)
    })

type StreamData = List[Entry]

object StreamStore:
  private val streams: TreeMap[String, StreamData] =
    TreeMap[String, StreamData]()

  /** Creates a new stream with the given name if it does not already exist.
    * Throws an exception if the stream already exists.
    * @param name
    *   The name of the stream to create.
    */
  def makeStream(name: String): Unit =
    if !streams.contains(name) then streams(name) = List.empty
    else throw Exception(s"Stream '$name' already exists")

  /** Adds an entry to the specified stream. Creates the stream if it does not
    * exist.
    *
    * @param name
    *   The name of the stream to which the entry will be added.
    * @param entry
    *   The entry to add to the stream.
    */
  def addEntryToStream(name: String, entry: Entry): Unit =
    if streams.contains(name) then
      val stream = streams(name)
      streams(name) = stream :+ entry
      Some(entry)
    else
      makeStream(name)
      addEntryToStream(name, entry)

  def streamExists(name: String): Boolean =
    streams.contains(name)

  def getStream(name: String): Option[StreamData] =
    streams.get(name)

  def firstEntry(name: String): Option[EntryID] =
    streams.get(name) match
      case Some(entries) if entries.nonEmpty =>
        Some(entries.head.id)
      case _ => None

  def lastEntry(name: String): Option[EntryID] =
    streams.get(name) match
      case Some(entries) if entries.nonEmpty =>
        Some(entries.last.id)
      case _ => None

  def lastEntry(name: String, timeMS: Long): Option[EntryID] =
    lastEntry(name) match
      case Some(entry) if entry.msTime == timeMS => Some(entry)
      case _                                     => None
